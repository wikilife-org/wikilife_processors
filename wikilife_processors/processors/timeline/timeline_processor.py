# coding=utf-8

from wikilife_processors.processors.base_user_processor import BaseUserProcessor
from wikilife_utils.date_utils import DateUtils
from wikilife_utils.parsers.date_parser import DateParser
import dateutil


class TimelineProcessorException(Exception):
    pass

class TimelineProcessor(BaseUserProcessor):
    """
    Timeline processor

    http://www.mongodb.org/display/DOCS/Sharding
    sharded-collection: [
        {
            "user_id": "QWERTY", 
            "date": "2012-02-13", 
            "update_datetime_utc": datetimeUTC, #needed for DELETE opers 
            "logs": [
                {
                    "id": 206752, 
                    "text": "Running  60 minutes", 
                    "time": "2012-02-13 23:53:28 +0000", #execute_time
                    "log_update_datetime_utc": datetimeUTC, #generated by server
                    "log_update_datetime" : datetime #generated by client
                    "nodes": [
                        {"nodeId": 296, "metricId": 111, "value": 60.0}
                    ], 
                }, 
                ...
        },
        ...
    ]
    """

    def accept(self, final_log):
        return True, final_log["nodes"]

    def insert(self, final_log, log_nodes):
        #read
        user_id = final_log["user_id"] 
        date = DateUtils.get_date(final_log["execute_datetime"])
        day = self._mgrs.timeline_mgr.get_user_day(user_id, date)

        #modify
        timeline_log = self._create_timeline_log(final_log)

        if day == None:
            day = {}
            day["user_id"] = user_id
            day["date"] = date
            day["logs"] = [timeline_log]

        else:
            if self._get_day_log_by_id(day, timeline_log["id"]) != None:
                raise TimelineProcessorException("Log id %s already exists in day('%s', '%s')" %(timeline_log["id"], day["user_id"], day["date"]))

            day["logs"].append(timeline_log)

        #save
        self._mgrs.timeline_mgr.save_user_day(day)
    
    def delete(self, old_final_log, old_log_nodes):

        #read
        user_id = old_final_log["user_id"] 
        date = DateUtils.get_date(old_final_log["execute_datetime"])
        day = self._mgrs.timeline_mgr.get_user_day(user_id, date)
        original_log_id = old_final_log["_id"]

        #modify
        if day == None:
            raise TimelineProcessorException("Cannot find User day('%s', '%s')" %(day["user_id"], day["date"]))

        del_log = self._get_day_log_by_id(day, original_log_id)
        if del_log == None:
            raise TimelineProcessorException("Log id %s not exists in day('%s', '%s')" %(original_log_id, day["user_id"], day["date"]))

        day["logs"].remove(del_log)

        #save
        if len(day["logs"]) == 0:
            self._mgrs.timeline_mgr.delete_user_day(day)

        else:
            self._mgrs.timeline_mgr.save_user_day(day)

    def remove_by_user(self, user_id):
        self._mgrs.timeline_mgr.delete_by_user(user_id)

    """ helpers """

    def _create_timeline_log(self, log):
        info = {}
        answer = self._mgrs.answer_mgr.get_answer_by_log_id(log["_id"])

        if answer != None:
            info["type"] = "answer"
            info["answer_id"] = answer["_id"]
            info["question_id"] = answer["question_id"]

        else:
            info["type"] = "log"

        return {
            "id": log["_id"],
            "info": info,
            "text": log["text"],
            "time": log["execute_datetime"],
            "log_update_datetime_utc": DateUtils.get_datetime_utc(),
            "log_update_datetime": DateParser.from_datetime(log["update_datetime"]),
            "nodes": log["nodes"]
        }

    def _get_day_log_by_id(self, day, log_id):
        for log in day["logs"]:
            if log["id"] == log_id:
                return log

        return None

    def _get_day_date(self, log):
        #TODO remove/set to zero  hh mm ss
        return dateutil.parser.parse(log["execute_datetime"])
